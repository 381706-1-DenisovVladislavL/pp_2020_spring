\documentclass[14pt,a4paper,report]{ncc}

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\pagestyle{plain}
\usepackage[a4paper, mag=1000, left=2.5cm, right=1cm, top=2cm, bottom=2cm, headsep=0.7cm, footskip=1cm]{geometry}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage[]{caption}
\usetikzlibrary{tikzmark}


\setlength{\parskip}{0.2cm}

\lstset{language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}



\begin{document}
	\begin{titlepage}
		
		\begin{center}
			Министерство науки и высшего образования Российской Федерации
		\end{center}
		
		\begin{center}
			Федеральное государственное автономное образовательное учреждение высшего образования \\
			Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
		\end{center}
		
		\begin{center}
			Институт информационных технологий, математики и механики
		\end{center}
		
		\vspace{4em}
		
		\begin{center}
			\textbf{\LargeОтчет по лабораторной работе} \\
		\end{center}
		\begin{center}
			\textbf{\Large«Умножение разреженных матриц. Элементы комплексного типа. Формат хранения матрицы – столбцовый (CCS)»} \\
		\end{center}
		
		\vspace{11em}
		\hfill\parbox{6.5cm}{
			\textbf{Выполнил:} \\ студент группы 381708-1 \\ Шеметов Ф.А.\\
			\\
			\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.
		}
		
		\vspace{\fill}
		\begin{center} Нижний Новгород \\ 2020 \end{center}
		
	\end{titlepage}
	
	\setcounter{page}{2}
	
	\tableofcontents
	\newpage
	
	\section*{Введение}
	\addcontentsline{toc}{section}{Введение}
	
	Разрежённой матрицей называются матрицы, которые преимущественно состоят из нулевых элементов. Возникают разрежённые матрицы при решение различных задач связанных с научной и инженерной областью, где присутствует большое число неизвестных, связанных между собой уравнениями.
	\par Так как в разрежённых матрицах содержится большинство значений в виде нулей, то любая арифметическая операция с этими матрицами увеличивает лишние вычислительные затраты. Для того чтобы снизить вычислительные затраты, были придуманы разные способы хранений разрежённых матриц и один из них --- Формат хранения CCS\footnote{Compressed Column Storage}. 
	\par Формат хранения CCS представляет собой структуру данных, которая позволяет хранить матрицу в виде трех массивов. Первый массив хранит ненулевые значения элементов матрицы. Второй массив хранит номера строк для каждого элемента. Третий массив хранит индекс начала каждого столбца.
	\par Сам формат хранения CCS предоставляет минимальные требования к памяти и значительно уменьшает вычислительные затраты при арифметических операциях с разрежёнными матрицами.
	\par Цель лабораторной работы --- изучение принципа хранения и разработка алгоритма умножения разрежённых матриц в формате CCS с использованием технологий параллельного программирования.
	\newpage
	
	\section*{Постановка задачи}
	\addcontentsline{toc}{section}{Постановка задачи}
	В данной лабораторной работе ставится задача в виде разработки нескольких проектов, где нужно реализовать алгоритм умножения разрежённых матриц в формате хранения CCS с элементами комплексного типа.
	\par Проект будет включать в себя:
	\begin{itemize}
		\item Набор юнит-тестов использующие Google C++ Testing Framework.
		\item Исходный и заголовочный файл. В заголовочном файле реализован интерфейс класса, а в самом исходном файле реализован код последовательного алгоритма умножения разрежённых матриц в формате хранения CCS или параллельный алгоритм с технологиями OpenMP, TBB, std::threads.
		\item файл CMake для сборки проекта.
	\end{itemize}
	\newpage
	
	
	\section*{Описание алгоритма}
	\addcontentsline{toc}{section}{Описание алгоритма}
	В нашей лабораторной работе нужно реализовать алгоритм умножения разрежённых матриц в формате хранения CCS с элементами комплексного типа.
	\parЧтобы реализовать алгоритм умножения, нужно сгенерировать саму разрежённую матрицу. Для этого мы будем использовать ГПСЧ \textit{mt19937}, который позволяет генерировать оптимально-хорошую последовательность случайных чисел. Так как мы реализовываем не плотную, а разрежённую матрицу которая преимущественно состоит из нулей, то для ГПСЧ нужно задать параметр в виде вещественного числа от 0 до 1...
	\parПосле полученного сгенерированного класса разрежённой матрицы, нам нужно реализовать хранение этой матрицы в формате CCS. Но так как перенос из разрежённой матрицы в формат хранения CCS увеличивает вычислительные затраты, то для их уменьшения, мы сначала должны транспонировать матрицу и перевести в формат хранения CRS, получая формат хранения CCS, но возникает проблема в том, что разрежённая матрица может быть больших размеров, где большинство значений это нули, поэтому транспонирование этой матрицы будет тоже для нас затратным делом. И чтобы снизить затраты, нужен алгоритм транспонирования, который сразу преобразует матрицу из формата хранения CRS в формат хранения CCS.
	\parПоэтому, первым делом мы преобразуем разрежённую матрицу в CRS формат. Все ненулевые значения, обходя последовательно по строкам матрицы, передаём в первый вектор(\verb|value|), во второй вектор(\verb|col_index|) мы передаём номера столбцов ненулевых значений матрицы, в третий вектор(\verb|row_offset|) передаём индексы начала новых строк во втором векторе. Получив объект класса разрежённой матрицы в формате CRS, следующий шаг это алгоритм транспонирования CRS в CCS. Сформируем новый объект класса \verb|obj| с пустыми векторами, в первом векторе(\verb|obj.value|) также будут ненулевые значение, во втором(\verb|obj.row_index|) уже будут номера строк, а в третьем(\verb|obj.col_offset|) индексы начала новых столбцов. Сначала мы заполняем третий вектор  нулями и инкрементируем значение этого вектора, где индекс является номер столбца. Получив заполненный третий вектор, мы обращаемся к нему и получаем индекс к вектору \verb|obj.col_offset| и \verb|obj.value|, где по-этому индексу во втором векторе(\verb|obj.row_index|) в элементы передаём номера строк, а в первом(\verb|obj.value|) в элементы передаём значения элементов первого вектора формата хранения CRS.
	\parПолучив объект класса разрежённой матрицы в формате хранения CCS, мы теперь можем реализовать алгоритм умножения CCS матриц. Умножение двух CCS матриц происходит по алгоритму JKI-типа.
	\begin{figure}[h!]
		\[
		\tikzmarknode{mat}{\begin{bmatrix}
		a_{1,1} & a_{1,2} & \cdots & a_{1,k} \\
		a_{2,1} & a_{2,2} & \cdots & a_{2,k} \\
		\vdots  & \vdots  & \ddots & \vdots  \\
		a_{i,1} & a_{i,2} & \cdots & a_{i,k}
		\end{bmatrix}} *
		\hspace*{1cm}\tikzmarknode{mat2}{\begin{bmatrix}
		b_{1,1} & b_{1,2} & \cdots & b_{1,j} \\
		b_{2,1} & b_{2,2} & \cdots & b_{2,j} \\
		\vdots  & \vdots  & \ddots & \vdots  \\
		b_{k,1} & b_{k,2} & \cdots & b_{k,j}
		\end{bmatrix}} =
		\tikzmarknode{mat3}{\begin{bmatrix}
		c_{1,1} & c_{1,2} & \cdots & c_{1,j} \\
		c_{2,1} & c_{2,2} & \cdots & c_{2,j} \\
		\vdots  & \vdots  & \ddots & \vdots  \\
		c_{i,1} & c_{i,2} & \cdots & c_{i,j}
		\end{bmatrix}}
		\begin{tikzpicture}[overlay,remember picture]
		\draw[black,thick,-latex] node[anchor=south west] (nn1) at (mat.north west)
		{} (nn1.east) -- (nn1-|mat.north east) 
		node[midway,above,black]{$k$};
		\draw[black,thick,-latex] node[anchor=north east,align=center] (nn2) at (mat.north west)
		{} (nn2.south) -- (nn2.south|-mat.south west) 
		node[midway,above,black,rotate=90]{$i$};
		\end{tikzpicture}
		\begin{tikzpicture}[overlay,remember picture]
		\draw[black,thick,-latex] node[anchor=south west] (nn1) at (mat2.north west)
		{} (nn1.east) -- (nn1-|mat2.north east) 
		node[midway,above,black]{$j$};
		\draw[black,thick,-latex] node[anchor=north east,align=center] (nn2) at (mat2.north west)
		{} (nn2.south) -- (nn2.south|-mat2.south west) 
		node[midway,above,black,rotate=90]{$k$};
		\end{tikzpicture}
		\begin{tikzpicture}[overlay,remember picture]
		\draw[black,thick,-latex] node[anchor=south west] (nn1) at (mat3.north west)
		{} (nn1.east) -- (nn1-|mat3.north east) 
		node[midway,above,black]{$j$};
		\draw[black,thick,-latex] node[anchor=north west,align=center] (nn2) at (mat3.north east)
		{} (nn2.south) -- (nn2.south|-mat3.south) 
		node[midway,above,black,rotate=-90]{$i$};
		\end{tikzpicture}
		\]
	\caption{Умножение разрежённых матриц в формате хранения CCS. Постолбцовый JKI алгоритм.}
	\end{figure}
	
	
	
	
	
	
	//, начинаем цикл обхода столбца матрицы B, взяв столбец, идём по вектору \verb|col_offset| и получаем индекс расположения элемента в строках. Индекс расположения элемента в строках подставляем в индекс вектора \verb|col_offset| матрицы A
	
	
	
	
	
	
	
	//Начинаем идти по номерам строк и по третьему вектору, где индекс это номер строки, после чего получаем значение указывающее на новое начало каждой строки во втором векторе. Подставляем это значение во второй вектор и получаем значение номера столбца, который представляет собой индекс нового третьего вектора, и по этому индексу значение массива инкрементируется, пока полностью не получим третий вектор формата CCS, указывающий на новое начало каждого столбца. После того как получили третий вектор формата CCS, нам нужно получить вектор элементов и вектор с номерами строк. Снова идем по номерам строк и третьему вектору формата CRS, где индекс это номер строки. Получаем значение указывающее на новое начало каждой строки во втором векторе//
	
	
	
	
\end{document}